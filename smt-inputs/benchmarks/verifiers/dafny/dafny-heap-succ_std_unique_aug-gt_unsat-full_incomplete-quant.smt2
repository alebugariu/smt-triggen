(set-option :smt.auto-config false)
(set-option :smt.mbqi false)
(set-option :sat.random_seed 488)
(set-option :smt.random_seed 599)
(set-option :nlsat.seed 611)
(set-option :memory_max_size 6000)
(declare-sort T@U 0)
(declare-sort RegExStr 0)
(declare-sort RMode 0)
(declare-sort T@T 0)
(declare-fun boolType () T@T)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun MapType0Type (T@T) T@T)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun alloc () T@U)
(declare-fun $Heap () T@U)
(declare-fun r0 () T@U)

(assert (! (forall ((arg0@@3py0 Bool)) (! (and (or (not (U_2_bool (bool_2_U arg0@@3py0))) arg0@@3py0) (or (U_2_bool (bool_2_U arg0@@3py0)) (not arg0@@3py0))) :pattern ((bool_2_U arg0@@3py0)) )) :named A1__10))
(assert (! (forall ((arg0@@4py0 Bool)) (! (= (type (bool_2_U arg0@@4py0)) boolType) :pattern ((bool_2_U arg0@@4py0)) )) :named A1__12))
(assert (! (forall ((arg0@@10py0 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@10py0)) arg0@@10py0) :pattern ((FieldType arg0@@10py0)) )) :named A5__3))
(assert (! (forall ((arg0@@12py0 T@U)(arg1@@0py0 T@U)(arg2@@0py0 T@U)(arg3py0 T@U)) (! (= (type (MapType0Store arg0@@12py0 arg1@@0py0 arg2@@0py0 arg3py0)) (MapType0Type (type arg1@@0py0))) :pattern ((MapType0Store arg0@@12py0 arg1@@0py0 arg2@@0py0 arg3py0)) )) :named A5__5))
(assert (! (forall ((mpy0 T@U)(x0py0 T@U)(x1py0 T@U)(valpy0 T@U)) (! (or (not (= (type valpy0) (FieldTypeInv0 (type x1py0)))) (= (MapType0Select (MapType0Store mpy0 x0py0 x1py0 valpy0) x0py0 x1py0) valpy0)) :pattern ((MapType0Store mpy0 x0py0 x1py0 valpy0)) )) :named A5__6))
(assert (! (forall ((hpy0 T@U)(rpy0 T@U)(fpy0 T@U)(x@@6py0 T@U)) (! (or ($HeapSucc hpy0 (MapType0Store hpy0 rpy0 fpy0 x@@6py0)) (not (= (type hpy0) (MapType0Type refType))) (not (= (type rpy0) refType)) (not (= (type fpy0) (FieldType (type x@@6py0))))) :pattern ((MapType0Store hpy0 rpy0 fpy0 x@@6py0)) )) :named A6))
(assert (! (= (type alloc) (FieldType boolType)) :named A7))
(assert (! (forall ((h@@0py0 T@U)(kpy0 T@U)) (! (or (not (= (type h@@0py0) (MapType0Type refType))) (not (= (type kpy0) (MapType0Type refType))) (not ($HeapSucc h@@0py0 kpy0)) (forall ((opy0 T@U)) (! (or (U_2_bool (MapType0Select kpy0 opy0 alloc)) (not (= (type opy0) refType)) (not (U_2_bool (MapType0Select h@@0py0 opy0 alloc)))) :pattern ((MapType0Select kpy0 opy0 alloc)) ))) :pattern (($HeapSucc h@@0py0 kpy0)) )) :named A8))
(assert (! (= (type r0) refType) :named A9__2))

;(declare-fun dummy (T@U) Bool)
;(assert (! (dummy (MapType0Store (MapType0Store $Heap r0 alloc (bool_2_U true)) r0 alloc (bool_2_U false))) :named A10))

(check-sat)
(get-info :reason-unknown)
;z3 -T:600 smt-inputs/benchmarks/verifiers/dafny/pattern_augmenter/ematching/tmp/dafny-heap-succ_std_unique_aug-gt_unsat-full.smt2
;unknown
;((:reason-unknown "smt tactic failed to show goal to be sat/unsat (incomplete quantifiers)"))

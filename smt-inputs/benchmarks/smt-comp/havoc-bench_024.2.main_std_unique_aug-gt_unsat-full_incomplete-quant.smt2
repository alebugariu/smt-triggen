(set-info :smt-lib-version 2.6)
(set-info :source | VCC and HAVOC benchmarks. Contributed by Nikolaj Bjorner, Leonardo de Moura, Michal Moskal, and Shaz Qadeer. |)
(set-info :category "industrial")
(set-info :status unsat)
(set-logic UFNIA)
(set-option :smt.auto-config false)
(set-option :smt.mbqi false)
(set-option :sat.random_seed 488)
(set-option :smt.random_seed 599)
(set-option :nlsat.seed 611)
(set-option :memory_max_size 6000)
(declare-fun x (Int Int) Int)
(declare-sort RegExStr 0)
(declare-sort RMode 0)
(declare-fun true_1 () Int)
(declare-fun false_1 () Int)
(declare-fun intGreater (Int Int) Int)
(declare-fun intAtLeast (Int Int) Int)
(declare-fun intAtMost (Int Int) Int)
(declare-fun intLess (Int Int) Int)
(declare-fun anyNeq (Int Int) Int)
(declare-fun anyEqual (Int Int) Int)
(declare-fun boolNot (Int) Int)
(declare-fun boolOr (Int Int) Int)
(declare-fun boolAnd (Int Int) Int)
(declare-fun boolImplies (Int Int) Int)
(declare-fun boolIff (Int Int) Int)
(declare-fun select2 (Int Int Int) Int)
(declare-fun store2 (Int Int Int Int) Int)
(declare-fun select1 (Int Int) Int)
(declare-fun store1 (Int Int Int) Int)
(declare-fun array () Int)
(declare-fun NULL_CHECK (Int) Int)
(declare-fun LIFT (Int) Int)
(declare-fun BIT_BAND (Int Int) Int)
(declare-fun POW2 (Int) Int)
(declare-fun choose (Int Int Int) Int)
(declare-fun DIV (Int Int) Int)
(declare-fun MULT (Int Int) Int)
(declare-fun PLUS (Int Int Int) Int)
(declare-fun MINUS_LEFT_PTR (Int Int Int) Int)
(declare-fun MINUS_BOTH_PTR_OR_BOTH_INT (Int Int Int) Int)
(declare-fun HasType (Int Int) Int)
(declare-fun UINT4_name () Int)
(declare-fun Match (Int Int) Int)
(declare-fun Field (Int) Int)
(declare-fun PINT4_name () Int)
(declare-fun PPINT4_name () Int)
(declare-fun INT4_name () Int)
(declare-fun Values (Int) Int)
(declare-fun Unified (Int) Int)
(declare-fun Disjoint (Int Int) Int)
(declare-fun Subset (Int Int) Int)
(declare-fun Equal (Int Int) Int)
(declare-fun Inverse (Int Int) Int)
(declare-fun Difference (Int Int) Int)
(declare-fun Singleton (Int) Int)
(declare-fun Union (Int Int) Int)
(declare-fun Dereference (Int Int) Int)
(declare-fun Intersection (Int Int) Int)
(declare-fun Empty () Int)
(declare-fun HavocArray (Int Int Int) Int)
(declare-fun AtLeast (Int Int) Int)
(declare-fun Rep (Int Int) Int)
(declare-fun FourBytesToInt (Int Int Int Int) Int)
(declare-fun TwoBytesToInt (Int Int) Int)
(declare-fun OneByteToInt (Int) Int)
(declare-fun BYTE () Int)
(declare-fun FREED () Int)
(declare-fun ALLOCATED () Int)
(declare-fun UNALLOCATED () Int)
(declare-fun Base (Int) Int)
(declare-fun alloc_1 () Int)
(declare-fun alloc () Int)
(declare-fun Mem_2 () Int)
(declare-fun Mem () Int)
(declare-fun result_main_13_5_1_ () Int)
(declare-fun call4064formal_new_0 () Int)
(declare-fun call4300formal_ret_0 () Int)
(declare-fun analysis_havoc_assert_arg_1_4__0 () Int)
(declare-fun Mem_1 () Int)
(declare-fun Mem_0 () Int)
(declare-fun alloc_0 () Int)
(declare-fun result___analysis_havoc_assert_17_25_3_ () Int)
(declare-fun analysis_havoc_assert_arg_1_4_ () Int)
(declare-fun x_1 () Int)
(declare-fun result_malloc_14_23_2_ () Int)
(declare-fun ?x_1!2 (Int Int) Int)
(declare-fun ?x_1!3 (Int Int) Int)
(declare-fun ?k!0 (Int Int) Int)
(declare-fun ?y!1 (Int Int Int) Int)
(declare-fun ?a!4 () Int)
(declare-fun ?a!5 () Int)
(declare-fun ?a!6 () Int)
(declare-fun ?f!8 () Int)
(declare-fun ?f!9 () Int)
(declare-fun ?m!7 () Int)
(assert (! (forall ((?Apy0 Int)(?ipy0 Int)(?jpy0 Int)(?vpy0 Int)) (! (or (= ?ipy0 ?jpy0) (= (select1 (store1 ?Apy0 ?ipy0 ?vpy0) ?jpy0) (select1 ?Apy0 ?jpy0))) :pattern ((select1 (store1 ?Apy0 ?ipy0 ?vpy0) ?jpy0)) )) :named A0_0))
(assert (! (forall ((?Apy1 Int)(?ipy1 Int)(?vpy1 Int)) (! (= (select1 (store1 ?Apy1 ?ipy1 ?vpy1) ?ipy1) ?vpy1) :pattern ((store1 ?Apy1 ?ipy1 ?vpy1)) )) :named A0_1))
(assert (! (forall ((?Apy2 Int)(?opy0 Int)(?fpy0 Int)(?ppy0 Int)(?gpy0 Int)(?vpy2 Int)) (! (or (= ?fpy0 ?gpy0) (= (select2 (store2 ?Apy2 ?opy0 ?fpy0 ?vpy2) ?ppy0 ?gpy0) (select2 ?Apy2 ?ppy0 ?gpy0))) :pattern ((select2 (store2 ?Apy2 ?opy0 ?fpy0 ?vpy2) ?ppy0 ?gpy0)) )) :named A0_2))
(assert (! (forall ((?Apy3 Int)(?opy1 Int)(?fpy1 Int)(?ppy1 Int)(?gpy1 Int)(?vpy3 Int)) (! (or (= ?opy1 ?ppy1) (= (select2 (store2 ?Apy3 ?opy1 ?fpy1 ?vpy3) ?ppy1 ?gpy1) (select2 ?Apy3 ?ppy1 ?gpy1))) :pattern ((select2 (store2 ?Apy3 ?opy1 ?fpy1 ?vpy3) ?ppy1 ?gpy1)) )) :named A0_3))
(assert (! (forall ((?Apy4 Int)(?opy2 Int)(?fpy2 Int)(?vpy4 Int)) (! (= (select2 (store2 ?Apy4 ?opy2 ?fpy2 ?vpy4) ?opy2 ?fpy2) ?vpy4) :pattern ((store2 ?Apy4 ?opy2 ?fpy2 ?vpy4)) )) :named A0_4))
(assert (! (forall ((?tpy0 Int)(?upy0 Int)(?vpy5 Int)) (! (or (not (= (x ?tpy0 ?upy0) true_1)) (not (= (x ?upy0 ?vpy5) true_1)) (= (x ?tpy0 ?vpy5) true_1)) :pattern ((x ?tpy0 ?upy0) (x ?upy0 ?vpy5)) )) :named A0_5))
(assert (! (forall ((?tpy1 Int)(?upy1 Int)) (! (or (= ?tpy1 ?upy1) (not (= (x ?tpy1 ?upy1) true_1)) (not (= (x ?upy1 ?tpy1) true_1))) :pattern ((x ?tpy1 ?upy1) (x ?upy1 ?tpy1)) )) :named A0_6))
(assert (! (forall ((?tpy2 Int)) (! (= (x ?tpy2 ?tpy2) true_1) :pattern ((x ?tpy2 ?tpy2)) )) :named A0_7))
(assert (! (forall ((?x_1py0 Int)(?ypy0 Int)) (! (and (or (not (= ?x_1py0 ?ypy0)) (not (= (anyNeq ?x_1py0 ?ypy0) true_1))) (or (= ?x_1py0 ?ypy0) (= (anyNeq ?x_1py0 ?ypy0) true_1))) :pattern ((anyNeq ?x_1py0 ?ypy0)) )) :named A0_8))
(assert (! (forall ((?x_1py1 Int)(?ypy1 Int)) (! (and (or (= ?x_1py1 true_1) (= ?ypy1 true_1) (not (= (boolOr ?x_1py1 ?ypy1) true_1))) (or (= (boolOr ?x_1py1 ?ypy1) true_1) (and (not (= ?x_1py1 true_1)) (not (= ?ypy1 true_1))))) :pattern ((boolOr ?x_1py1 ?ypy1)) )) :named A0_9))
(assert (! (forall ((?x_1py2 Int)(?ypy2 Int)) (! (and (or (= ?ypy2 true_1) (not (= ?x_1py2 true_1)) (not (= (boolImplies ?x_1py2 ?ypy2) true_1))) (or (= (boolImplies ?x_1py2 ?ypy2) true_1) (and (= ?x_1py2 true_1) (not (= ?ypy2 true_1))))) :pattern ((boolImplies ?x_1py2 ?ypy2)) )) :named A0_10))
(assert (! (forall ((?x_1py3 Int)(?ypy3 Int)) (! (and (or (not (<= ?x_1py3 ?ypy3)) (not (= (intGreater ?x_1py3 ?ypy3) true_1))) (or (<= ?x_1py3 ?ypy3) (= (intGreater ?x_1py3 ?ypy3) true_1))) :pattern ((intGreater ?x_1py3 ?ypy3)) )) :named A0_11))
(assert (! (forall ((?x_1py4 Int)(?ypy4 Int)) (! (and (or (not (<= ?ypy4 ?x_1py4)) (not (= (intLess ?x_1py4 ?ypy4) true_1))) (or (= (intLess ?x_1py4 ?ypy4) true_1) (<= ?ypy4 ?x_1py4))) :pattern ((intLess ?x_1py4 ?ypy4)) )) :named A0_12))
(assert (! (forall ((?x_1py5 Int)(?ypy5 Int)) (! (and (or (not (= (anyEqual ?x_1py5 ?ypy5) true_1)) (= ?x_1py5 ?ypy5)) (or (= (anyEqual ?x_1py5 ?ypy5) true_1) (not (= ?x_1py5 ?ypy5)))) :pattern ((anyEqual ?x_1py5 ?ypy5)) )) :named A0_13))
(assert (! (forall ((?x_1py6 Int)(?ypy6 Int)) (! (and (or (not (= (boolAnd ?x_1py6 ?ypy6) true_1)) (and (= ?x_1py6 true_1) (= ?ypy6 true_1))) (or (= (boolAnd ?x_1py6 ?ypy6) true_1) (not (= ?x_1py6 true_1)) (not (= ?ypy6 true_1)))) :pattern ((boolAnd ?x_1py6 ?ypy6)) )) :named A0_14))
(assert (! (forall ((?x_1py7 Int)(?ypy7 Int)) (! (and (or (not (= (boolIff ?x_1py7 ?ypy7) true_1)) (and (or (not (= ?x_1py7 true_1)) (= ?ypy7 true_1)) (or (= ?x_1py7 true_1) (not (= ?ypy7 true_1))))) (or (= (boolIff ?x_1py7 ?ypy7) true_1) (and (or (= ?x_1py7 true_1) (= ?ypy7 true_1)) (or (not (= ?x_1py7 true_1)) (not (= ?ypy7 true_1)))))) :pattern ((boolIff ?x_1py7 ?ypy7)) )) :named A0_15))
(assert (! (forall ((?x_1py8 Int)(?ypy8 Int)) (! (and (or (not (= (intAtLeast ?x_1py8 ?ypy8) true_1)) (<= ?ypy8 ?x_1py8)) (or (= (intAtLeast ?x_1py8 ?ypy8) true_1) (not (<= ?ypy8 ?x_1py8)))) :pattern ((intAtLeast ?x_1py8 ?ypy8)) )) :named A0_16))
(assert (! (forall ((?x_1py9 Int)(?ypy9 Int)) (! (and (or (not (= (intAtMost ?x_1py9 ?ypy9) true_1)) (<= ?x_1py9 ?ypy9)) (or (= (intAtMost ?x_1py9 ?ypy9) true_1) (not (<= ?x_1py9 ?ypy9)))) :pattern ((intAtMost ?x_1py9 ?ypy9)) )) :named A0_17))
(assert (! (forall ((?x_1py10 Int)) (! (and (or (not (= ?x_1py10 true_1)) (not (= (boolNot ?x_1py10) true_1))) (or (= ?x_1py10 true_1) (= (boolNot ?x_1py10) true_1))) :pattern ((boolNot ?x_1py10)) )) :named A0_18))
(assert (! (not (= false_1 true_1)) :named A0_19))
(assert (! (= (POW2 1) true_1) :named A1_0))
(assert (! (= (POW2 1024) true_1) :named A1_1))
(assert (! (= (POW2 1048576) true_1) :named A1_2))
(assert (! (= (POW2 128) true_1) :named A1_3))
(assert (! (= (POW2 131072) true_1) :named A1_4))
(assert (! (= (POW2 16) true_1) :named A1_5))
(assert (! (= (POW2 16384) true_1) :named A1_6))
(assert (! (= (POW2 16777216) true_1) :named A1_7))
(assert (! (= (POW2 2) true_1) :named A1_8))
(assert (! (= (POW2 2048) true_1) :named A1_9))
(assert (! (= (POW2 2097152) true_1) :named A1_10))
(assert (! (= (POW2 256) true_1) :named A1_11))
(assert (! (= (POW2 262144) true_1) :named A1_12))
(assert (! (= (POW2 32) true_1) :named A1_13))
(assert (! (= (POW2 32768) true_1) :named A1_14))
(assert (! (= (POW2 33554432) true_1) :named A1_15))
(assert (! (= (POW2 4) true_1) :named A1_16))
(assert (! (= (POW2 4096) true_1) :named A1_17))
(assert (! (= (POW2 4194304) true_1) :named A1_18))
(assert (! (= (POW2 512) true_1) :named A1_19))
(assert (! (= (POW2 524288) true_1) :named A1_20))
(assert (! (= (POW2 64) true_1) :named A1_21))
(assert (! (= (POW2 65536) true_1) :named A1_22))
(assert (! (= (POW2 8) true_1) :named A1_23))
(assert (! (= (POW2 8192) true_1) :named A1_24))
(assert (! (= (POW2 8388608) true_1) :named A1_25))
(assert (! (and (not (= UNALLOCATED ALLOCATED)) (not (= UNALLOCATED FREED)) (not (= UNALLOCATED BYTE)) (not (= UNALLOCATED INT4_name)) (not (= UNALLOCATED PINT4_name)) (not (= UNALLOCATED PPINT4_name)) (not (= UNALLOCATED UINT4_name)) (not (= UNALLOCATED array)) (not (= ALLOCATED FREED)) (not (= ALLOCATED BYTE)) (not (= ALLOCATED INT4_name)) (not (= ALLOCATED PINT4_name)) (not (= ALLOCATED PPINT4_name)) (not (= ALLOCATED UINT4_name)) (not (= ALLOCATED array)) (not (= FREED BYTE)) (not (= FREED INT4_name)) (not (= FREED PINT4_name)) (not (= FREED PPINT4_name)) (not (= FREED UINT4_name)) (not (= FREED array)) (not (= BYTE INT4_name)) (not (= BYTE PINT4_name)) (not (= BYTE PPINT4_name)) (not (= BYTE UINT4_name)) (not (= BYTE array)) (not (= INT4_name PINT4_name)) (not (= INT4_name PPINT4_name)) (not (= INT4_name UINT4_name)) (not (= INT4_name array)) (not (= PINT4_name PPINT4_name)) (not (= PINT4_name UINT4_name)) (not (= PINT4_name array)) (not (= PPINT4_name UINT4_name)) (not (= PPINT4_name array)) (not (= UINT4_name array))) :named A1_26))
(assert (! (forall ((?Mpy0 Int)(?x_1py11 Int)(?ypy10 Int)) (! (= (Unified (store1 ?Mpy0 (Field ?x_1py11) (store1 (select1 ?Mpy0 (Field ?x_1py11)) ?x_1py11 ?ypy10))) (store1 (Unified ?Mpy0) ?x_1py11 ?ypy10)) :pattern ((Unified (store1 ?Mpy0 (Field ?x_1py11) (store1 (select1 ?Mpy0 (Field ?x_1py11)) ?x_1py11 ?ypy10)))) )) :named A1_27))
(assert (! (forall ((?Mpy1 Int)(?x_1py12 Int)) (! (= (select1 (Unified ?Mpy1) ?x_1py12) (select1 (select1 ?Mpy1 (Field ?x_1py12)) ?x_1py12)) :pattern ((select1 (Unified ?Mpy1) ?x_1py12)) )) :named A1_28))
(assert (! (forall ((?Spy0 Int)(?Tpy0 Int)) (! (and (or (not (= (Equal ?Spy0 ?Tpy0) true_1)) (and (= (Subset ?Spy0 ?Tpy0) true_1) (= (Subset ?Tpy0 ?Spy0) true_1))) (or (= (Equal ?Spy0 ?Tpy0) true_1) (not (= (Subset ?Spy0 ?Tpy0) true_1)) (not (= (Subset ?Tpy0 ?Spy0) true_1)))) :pattern ((Equal ?Spy0 ?Tpy0)) )) :named A1_29))
(assert (! (forall ((?Spy1 Int)(?Tpy1 Int)) (! (or (= (Disjoint ?Spy1 ?Tpy1) true_1) (and (= (select1 ?Spy1 (?x_1!3 ?Tpy1 ?Spy1)) true_1) (= (select1 ?Tpy1 (?x_1!3 ?Tpy1 ?Spy1)) true_1))) :pattern ((Disjoint ?Spy1 ?Tpy1)) )) :named A1_30))
(assert (! (forall ((?Spy2 Int)(?Tpy2 Int)) (! (or (= (Subset ?Spy2 ?Tpy2) true_1) (and (= (select1 ?Spy2 (?x_1!2 ?Tpy2 ?Spy2)) true_1) (not (= (select1 ?Tpy2 (?x_1!2 ?Tpy2 ?Spy2)) true_1)))) :pattern ((Subset ?Spy2 ?Tpy2)) )) :named A1_31))
(assert (! (forall ((?apy0 Int)(?a_sizepy0 Int)(?bpy0 Int)) (! (= (MINUS_LEFT_PTR ?apy0 ?a_sizepy0 ?bpy0) (+ ?apy0 (* (- 1) ?bpy0 ?a_sizepy0))) :pattern ((MINUS_LEFT_PTR ?apy0 ?a_sizepy0 ?bpy0)) )) :named A1_32))
(assert (! (forall ((?apy1 Int)(?a_sizepy1 Int)(?bpy1 Int)) (! (= (PLUS ?apy1 ?a_sizepy1 ?bpy1) (+ ?apy1 (* ?bpy1 ?a_sizepy1))) :pattern ((PLUS ?apy1 ?a_sizepy1 ?bpy1)) )) :named A1_33))
(assert (! (forall ((?apy2 Int)(?bpy2 Int)(?cpy0 Int)) (! (or (= ?apy2 true_1) (= (choose ?apy2 ?bpy2 ?cpy0) ?cpy0)) :pattern ((choose ?apy2 ?bpy2 ?cpy0)) )) :named A1_34))
(assert (! (forall ((?apy3 Int)(?bpy3 Int)(?cpy1 Int)) (! (or (not (= ?apy3 true_1)) (= (choose ?apy3 ?bpy3 ?cpy1) ?bpy3)) :pattern ((choose ?apy3 ?bpy3 ?cpy1)) )) :named A1_35))
(assert (! (forall ((?apy4 Int)(?bpy4 Int)(?sizepy0 Int)) (! (and (<= (* (MINUS_BOTH_PTR_OR_BOTH_INT ?apy4 ?bpy4 ?sizepy0) ?sizepy0) (+ ?apy4 (* (- 1) ?bpy4))) (not (<= (* (+ 1 (MINUS_BOTH_PTR_OR_BOTH_INT ?apy4 ?bpy4 ?sizepy0)) ?sizepy0) (+ ?apy4 (* (- 1) ?bpy4))))) :pattern ((MINUS_BOTH_PTR_OR_BOTH_INT ?apy4 ?bpy4 ?sizepy0)) )) :named A1_36))
(assert (! (forall ((?apy5 Int)(?bpy5 Int)) (! (= (MULT ?apy5 ?bpy5) (* ?bpy5 ?apy5)) :pattern ((MULT ?apy5 ?bpy5)) )) :named A1_37))
(assert (! (forall ((?apy6 Int)(?bpy6 Int)) (! (or (<= 0 ?bpy6) (<= 0 ?apy6) (and (<= ?apy6 (* (DIV ?apy6 ?bpy6) ?bpy6)) (not (<= ?apy6 (* (+ 1 (DIV ?apy6 ?bpy6)) ?bpy6))))) :pattern ((DIV ?apy6 ?bpy6)) )) :named A1_38))
(assert (! (forall ((?apy7 Int)(?bpy7 Int)) (! (or (<= ?bpy7 0) (<= 0 ?apy7) (and (<= ?apy7 (* (DIV ?apy7 ?bpy7) ?bpy7)) (not (<= ?apy7 (* (+ (- 1) (DIV ?apy7 ?bpy7)) ?bpy7))))) :pattern ((DIV ?apy7 ?bpy7)) )) :named A1_39))
(assert (! (forall ((?apy8 Int)(?bpy8 Int)) (! (or (<= ?bpy8 0) (not (<= 0 ?apy8)) (and (<= (* (DIV ?apy8 ?bpy8) ?bpy8) ?apy8) (not (<= (* (+ 1 (DIV ?apy8 ?bpy8)) ?bpy8) ?apy8)))) :pattern ((DIV ?apy8 ?bpy8)) )) :named A1_40))
(assert (! (forall ((?apy9 Int)(?bpy9 Int)) (! (or (= (BIT_BAND ?apy9 ?bpy9) 0) (and (not (= ?apy9 0)) (not (= ?bpy9 0)))) :pattern ((BIT_BAND ?apy9 ?bpy9)) )) :named A1_41))
(assert (! (forall ((?apy10 Int)(?bpy10 Int)) (! (or (= ?apy10 ?bpy10) (not (= (POW2 ?apy10) true_1)) (not (= (POW2 ?bpy10) true_1)) (= (BIT_BAND ?apy10 ?bpy10) 0)) :pattern ((BIT_BAND ?apy10 ?bpy10)) )) :named A1_42))
(assert (! (forall ((?apy11 Int)(?bpy11 Int)) (! (or (not (= ?apy11 ?bpy11)) (= (BIT_BAND ?apy11 ?bpy11) ?apy11)) :pattern ((BIT_BAND ?apy11 ?bpy11)) )) :named A1_43))
(assert (! (forall ((?apy12 Int)(?bpy12 Int)) (! (or (not (<= 0 ?apy12)) (<= 0 ?bpy12) (and (<= (* (DIV ?apy12 ?bpy12) ?bpy12) ?apy12) (not (<= (* (+ (- 1) (DIV ?apy12 ?bpy12)) ?bpy12) ?apy12)))) :pattern ((DIV ?apy12 ?bpy12)) )) :named A1_44))
(assert (! (forall ((?apy13 Int)) (! (and (or (not (= (Match ?apy13 INT4_name) true_1)) (= (Field ?apy13) INT4_name)) (or (= (Match ?apy13 INT4_name) true_1) (not (= (Field ?apy13) INT4_name)))) :pattern ((Match ?apy13 INT4_name)) )) :named A1_45))
(assert (! (forall ((?apy14 Int)) (! (and (or (not (= (Match ?apy14 PINT4_name) true_1)) (= (Field ?apy14) PINT4_name)) (or (= (Match ?apy14 PINT4_name) true_1) (not (= (Field ?apy14) PINT4_name)))) :pattern ((Match ?apy14 PINT4_name)) )) :named A1_46))
(assert (! (forall ((?apy15 Int)) (! (and (or (not (= (Match ?apy15 PPINT4_name) true_1)) (= (Field ?apy15) PPINT4_name)) (or (= (Match ?apy15 PPINT4_name) true_1) (not (= (Field ?apy15) PPINT4_name)))) :pattern ((Match ?apy15 PPINT4_name)) )) :named A1_47))
(assert (! (forall ((?apy16 Int)) (! (and (or (not (= (Match ?apy16 UINT4_name) true_1)) (= (Field ?apy16) UINT4_name)) (or (= (Match ?apy16 UINT4_name) true_1) (not (= (Field ?apy16) UINT4_name)))) :pattern ((Match ?apy16 UINT4_name)) )) :named A1_48))
(assert (! (forall ((?apy17 Int)) (! (and (or (not (= ?apy17 true_1)) (not (= (LIFT ?apy17) 0))) (or (= ?apy17 true_1) (= (LIFT ?apy17) 0))) :pattern ((LIFT ?apy17)) )) :named A1_49))
(assert (! (forall ((?apy18 Int)) (! (or (= ?apy18 0) (= (NULL_CHECK ?apy18) 0)) :pattern ((NULL_CHECK ?apy18)) )) :named A1_50))
(assert (! (forall ((?apy19 Int)) (! (or (= ?apy19 0) (= (boolNot ?apy19) 0)) :pattern ((boolNot ?apy19)) )) :named A1_51))
(assert (! (forall ((?apy20 Int)) (! (or (not (= ?apy20 0)) (not (= (NULL_CHECK ?apy20) 0))) :pattern ((NULL_CHECK ?apy20)) )) :named A1_52))
(assert (! (forall ((?apy21 Int)) (! (or (not (= ?apy21 0)) (not (= (boolNot ?apy21) 0))) :pattern ((boolNot ?apy21)) )) :named A1_53))
(assert (! (forall ((?b0py0 Int)(?b1py0 Int)(?b2py0 Int)(?b3py0 Int)(?c0py0 Int)(?c1py0 Int)(?c2py0 Int)(?c3py0 Int)) (! (or (not (= (FourBytesToInt ?b0py0 ?b1py0 ?b2py0 ?b3py0) (FourBytesToInt ?c0py0 ?c1py0 ?c2py0 ?c3py0))) (and (= ?b0py0 ?c0py0) (= ?b1py0 ?c1py0) (= ?b2py0 ?c2py0) (= ?b3py0 ?c3py0))) :pattern ((FourBytesToInt ?b0py0 ?b1py0 ?b2py0 ?b3py0) (FourBytesToInt ?c0py0 ?c1py0 ?c2py0 ?c3py0)) )) :named A1_54))
(assert (! (forall ((?b0py1 Int)(?b1py1 Int)(?c0py1 Int)(?c1py1 Int)) (! (or (not (= (TwoBytesToInt ?b0py1 ?b1py1) (TwoBytesToInt ?c0py1 ?c1py1))) (and (= ?b0py1 ?c0py1) (= ?b1py1 ?c1py1))) :pattern ((TwoBytesToInt ?b0py1 ?b1py1) (TwoBytesToInt ?c0py1 ?c1py1)) )) :named A1_55))
(assert (! (forall ((?b0py2 Int)(?c0py2 Int)) (! (or (not (= (OneByteToInt ?b0py2) (OneByteToInt ?c0py2))) (= ?b0py2 ?c0py2)) :pattern ((OneByteToInt ?b0py2) (OneByteToInt ?c0py2)) )) :named A1_56))
(assert (! (forall ((?fpy3 Int)(?x_1py13 Int)(?ypy11 Int)(?zpy0 Int)) (! (or (= ?ypy11 ?zpy0) (= (Equal (Inverse (store1 ?fpy3 ?x_1py13 ?ypy11) ?zpy0) (Difference (Inverse ?fpy3 ?zpy0) (Singleton ?x_1py13))) true_1)) :pattern ((Inverse (store1 ?fpy3 ?x_1py13 ?ypy11) ?zpy0)) )) :named A1_57))
(assert (! (forall ((?fpy4 Int)(?x_1py14 Int)(?ypy12 Int)) (! (= (Equal (Inverse (store1 ?fpy4 ?x_1py14 ?ypy12) ?ypy12) (Union (Inverse ?fpy4 ?ypy12) (Singleton ?x_1py14))) true_1) :pattern ((Inverse (store1 ?fpy4 ?x_1py14 ?ypy12) ?ypy12)) )) :named A1_58))
(assert (! (forall ((?fpy5 Int)(?x_1py15 Int)) (! (= (select1 (Inverse ?fpy5 (select1 ?fpy5 ?x_1py15)) ?x_1py15) true_1) :pattern ((Inverse ?fpy5 (select1 ?fpy5 ?x_1py15))) )) :named A1_59))
(assert (! (forall ((?npy0 Int)(?x_1py16 Int)(?ypy13 Int)) (! (or (not (= (Rep ?npy0 ?x_1py16) (Rep ?npy0 ?ypy13))) (= (select1 (AtLeast ?npy0 ?x_1py16) ?ypy13) true_1) (not (<= ?x_1py16 ?ypy13))) :pattern ((AtLeast ?npy0 ?x_1py16) (Rep ?npy0 ?x_1py16) (Rep ?npy0 ?ypy13)) )) :named A1_60))
(assert (! (forall ((?npy1 Int)(?x_1py17 Int)(?ypy14 Int)) (! (or (not (= (select1 (AtLeast ?npy1 ?x_1py17) ?ypy14) true_1)) (and (<= ?x_1py17 ?ypy14) (= (Rep ?npy1 ?x_1py17) (Rep ?npy1 ?ypy14)))) :pattern ((select1 (AtLeast ?npy1 ?x_1py17) ?ypy14)) )) :named A1_61))
(assert (! (forall ((?npy2 Int)(?x_1py18 Int)(?zpy1 Int)) (! (= (Rep ?npy2 ?x_1py18) (Rep ?npy2 (PLUS ?x_1py18 ?npy2 ?zpy1))) :pattern ((PLUS ?x_1py18 ?npy2 ?zpy1)) )) :named A1_62))
(assert (! (forall ((?npy3 Int)(?x_1py19 Int)) (! (= (+ (Rep ?npy3 ?x_1py19) (* (- 1) ?x_1py19)) (* (?k!0 ?x_1py19 ?npy3) ?npy3)) :pattern ((Rep ?npy3 ?x_1py19)) )) :named A1_63))
(assert (! (forall ((?npy4 Int)(?x_1py20 Int)) (! (= (select1 (AtLeast ?npy4 ?x_1py20) ?x_1py20) true_1) :pattern ((AtLeast ?npy4 ?x_1py20)) )) :named A1_64))
(assert (! (forall ((?vpy6 Int)(?tpy3 Int)) (! (or (not (= (HasType ?vpy6 ?tpy3) true_1)) (= (select1 (Values ?tpy3) ?vpy6) true_1)) :pattern ((HasType ?vpy6 ?tpy3) (Values ?tpy3)) )) :named A1_65))
(assert (! (forall ((?vpy7 Int)(?tpy4 Int)) (! (or (not (= (select1 (Values ?tpy4) ?vpy7) true_1)) (= (HasType ?vpy7 ?tpy4) true_1)) :pattern ((select1 (Values ?tpy4) ?vpy7)) )) :named A1_66))
(assert (! (forall ((?vpy8 Int)) (! (and (or (not (= (HasType ?vpy8 PINT4_name) true_1)) (= ?vpy8 0) (and (not (<= ?vpy8 0)) (= (Match ?vpy8 INT4_name) true_1))) (or (= (HasType ?vpy8 PINT4_name) true_1) (and (not (= ?vpy8 0)) (or (<= ?vpy8 0) (not (= (Match ?vpy8 INT4_name) true_1)))))) :pattern ((HasType ?vpy8 PINT4_name)) :pattern ((Match ?vpy8 INT4_name)) )) :named A1_67))
(assert (! (forall ((?vpy9 Int)) (! (and (or (not (= (HasType ?vpy9 PPINT4_name) true_1)) (= ?vpy9 0) (and (not (<= ?vpy9 0)) (= (Match ?vpy9 PINT4_name) true_1))) (or (= (HasType ?vpy9 PPINT4_name) true_1) (and (not (= ?vpy9 0)) (or (<= ?vpy9 0) (not (= (Match ?vpy9 PINT4_name) true_1)))))) :pattern ((HasType ?vpy9 PPINT4_name)) :pattern ((Match ?vpy9 PINT4_name)) )) :named A1_68))
(assert (! (forall ((?vpy10 Int)) (! (= (HasType ?vpy10 INT4_name) true_1) :pattern ((HasType ?vpy10 INT4_name)) )) :named A1_69))
(assert (! (forall ((?vpy11 Int)) (! (= (HasType ?vpy11 UINT4_name) true_1) :pattern ((HasType ?vpy11 UINT4_name)) )) :named A1_70))
(assert (! (forall ((?x_1py21 Int)(?Spy3 Int)(?Mpy2 Int)) (! (or (not (= (select1 (Dereference ?Spy3 ?Mpy2) ?x_1py21) true_1)) (and (= ?x_1py21 (select1 ?Mpy2 (?y!1 ?Mpy2 ?Spy3 ?x_1py21))) (= (select1 ?Spy3 (?y!1 ?Mpy2 ?Spy3 ?x_1py21)) true_1))) :pattern ((select1 (Dereference ?Spy3 ?Mpy2) ?x_1py21)) )) :named A1_71))
(assert (! (forall ((?x_1py22 Int)(?Spy4 Int)(?Mpy3 Int)) (! (or (not (= (select1 ?Spy4 ?x_1py22) true_1)) (= (select1 (Dereference ?Spy4 ?Mpy3) (select1 ?Mpy3 ?x_1py22)) true_1)) :pattern ((select1 ?Mpy3 ?x_1py22) (select1 ?Spy4 ?x_1py22) (Dereference ?Spy4 ?Mpy3)) )) :named A1_72))
(assert (! (forall ((?x_1py23 Int)(?Spy5 Int)(?Tpy3 Int)) (! (and (or (= (select1 ?Spy5 ?x_1py23) true_1) (= (select1 ?Tpy3 ?x_1py23) true_1) (not (= (select1 (Union ?Spy5 ?Tpy3) ?x_1py23) true_1))) (or (= (select1 (Union ?Spy5 ?Tpy3) ?x_1py23) true_1) (and (not (= (select1 ?Spy5 ?x_1py23) true_1)) (not (= (select1 ?Tpy3 ?x_1py23) true_1))))) :pattern ((select1 (Union ?Spy5 ?Tpy3) ?x_1py23)) )) :named A1_73))
(assert (! (forall ((?x_1py24 Int)(?Spy6 Int)(?Tpy4 Int)) (! (and (or (not (= (select1 (Difference ?Spy6 ?Tpy4) ?x_1py24) true_1)) (and (= (select1 ?Spy6 ?x_1py24) true_1) (not (= (select1 ?Tpy4 ?x_1py24) true_1)))) (or (= (select1 ?Tpy4 ?x_1py24) true_1) (not (= (select1 ?Spy6 ?x_1py24) true_1)) (= (select1 (Difference ?Spy6 ?Tpy4) ?x_1py24) true_1))) :pattern ((select1 (Difference ?Spy6 ?Tpy4) ?x_1py24)) )) :named A1_74))
(assert (! (forall ((?x_1py25 Int)(?Spy7 Int)(?Tpy5 Int)) (! (and (or (not (= (select1 (Intersection ?Spy7 ?Tpy5) ?x_1py25) true_1)) (and (= (select1 ?Spy7 ?x_1py25) true_1) (= (select1 ?Tpy5 ?x_1py25) true_1))) (or (= (select1 (Intersection ?Spy7 ?Tpy5) ?x_1py25) true_1) (not (= (select1 ?Spy7 ?x_1py25) true_1)) (not (= (select1 ?Tpy5 ?x_1py25) true_1)))) :pattern ((select1 (Intersection ?Spy7 ?Tpy5) ?x_1py25)) )) :named A1_75))
(assert (! (forall ((?x_1py26 Int)(?Spy8 Int)(?Tpy6 Int)) (! (or (= (select1 (Intersection ?Spy8 ?Tpy6) ?x_1py26) true_1) (not (= (select1 ?Spy8 ?x_1py26) true_1)) (not (= (select1 ?Tpy6 ?x_1py26) true_1))) :pattern ((Intersection ?Spy8 ?Tpy6) (select1 ?Spy8 ?x_1py26)) )) :named A1_76))
(assert (! (forall ((?x_1py27 Int)(?Spy9 Int)(?Tpy7 Int)) (! (or (= (select1 (Intersection ?Spy9 ?Tpy7) ?x_1py27) true_1) (not (= (select1 ?Spy9 ?x_1py27) true_1)) (not (= (select1 ?Tpy7 ?x_1py27) true_1))) :pattern ((Intersection ?Spy9 ?Tpy7) (select1 ?Tpy7 ?x_1py27)) )) :named A1_77))
(assert (! (forall ((?x_1py28 Int)(?Spy10 Int)(?Tpy8 Int)) (! (or (= (select1 ?Tpy8 ?x_1py28) true_1) (not (= (select1 ?Spy10 ?x_1py28) true_1)) (= (select1 (Difference ?Spy10 ?Tpy8) ?x_1py28) true_1)) :pattern ((Difference ?Spy10 ?Tpy8) (select1 ?Spy10 ?x_1py28)) )) :named A1_78))
(assert (! (forall ((?x_1py29 Int)(?Spy11 Int)(?Tpy9 Int)) (! (or (= (select1 ?Tpy9 ?x_1py29) true_1) (not (= (select1 ?Spy11 ?x_1py29) true_1)) (not (= (Subset ?Spy11 ?Tpy9) true_1))) :pattern ((select1 ?Spy11 ?x_1py29) (Subset ?Spy11 ?Tpy9)) )) :named A1_79))
(assert (! (forall ((?x_1py30 Int)(?Spy12 Int)(?Tpy10 Int)) (! (or (not (= (select1 ?Spy12 ?x_1py30) true_1)) (= (select1 (Union ?Spy12 ?Tpy10) ?x_1py30) true_1)) :pattern ((Union ?Spy12 ?Tpy10) (select1 ?Spy12 ?x_1py30)) )) :named A1_80))
(assert (! (forall ((?x_1py31 Int)(?Spy13 Int)(?Tpy11 Int)) (! (or (not (= (select1 ?Spy13 ?x_1py31) true_1)) (not (= (select1 ?Tpy11 ?x_1py31) true_1)) (not (= (Disjoint ?Spy13 ?Tpy11) true_1))) :pattern ((select1 ?Spy13 ?x_1py31) (Disjoint ?Spy13 ?Tpy11) (select1 ?Tpy11 ?x_1py31)) )) :named A1_81))
(assert (! (forall ((?x_1py32 Int)(?Spy14 Int)(?Tpy12 Int)) (! (or (not (= (select1 ?Tpy12 ?x_1py32) true_1)) (= (select1 (Union ?Spy14 ?Tpy12) ?x_1py32) true_1)) :pattern ((Union ?Spy14 ?Tpy12) (select1 ?Tpy12 ?x_1py32)) )) :named A1_82))
(assert (! (forall ((?x_1py33 Int)(?npy5 Int)(?zpy2 Int)) (! (or (<= ?zpy2 0) (= (Equal (HavocArray ?x_1py33 ?npy5 ?zpy2) (Difference (AtLeast ?npy5 ?x_1py33) (AtLeast ?npy5 (PLUS ?x_1py33 ?npy5 ?zpy2)))) true_1)) :pattern ((HavocArray ?x_1py33 ?npy5 ?zpy2)) )) :named A1_83))
(assert (! (forall ((?x_1py34 Int)(?npy6 Int)(?zpy3 Int)) (! (or (not (<= ?zpy3 0)) (= (Equal (HavocArray ?x_1py34 ?npy6 ?zpy3) Empty) true_1)) :pattern ((HavocArray ?x_1py34 ?npy6 ?zpy3)) )) :named A1_84))
(assert (! (forall ((?x_1py35 Int)(?ypy15 Int)(?Spy15 Int)(?Mpy4 Int)) (! (or (= (select1 ?Spy15 ?x_1py35) true_1) (= (Equal (Dereference ?Spy15 (store1 ?Mpy4 ?x_1py35 ?ypy15)) (Dereference ?Spy15 ?Mpy4)) true_1)) :pattern ((Dereference ?Spy15 (store1 ?Mpy4 ?x_1py35 ?ypy15))) )) :named A1_85))
(assert (! (forall ((?x_1py36 Int)(?ypy16 Int)(?Spy16 Int)(?Mpy5 Int)) (! (or (not (= (select1 ?Spy16 ?x_1py36) true_1)) (= (Equal (Intersection (Inverse ?Mpy5 (select1 ?Mpy5 ?x_1py36)) ?Spy16) (Singleton ?x_1py36)) true_1) (= (Equal (Dereference ?Spy16 (store1 ?Mpy5 ?x_1py36 ?ypy16)) (Union (Dereference ?Spy16 ?Mpy5) (Singleton ?ypy16))) true_1)) :pattern ((Dereference ?Spy16 (store1 ?Mpy5 ?x_1py36 ?ypy16))) )) :named A1_86))
(assert (! (forall ((?x_1py37 Int)(?ypy17 Int)(?Spy17 Int)(?Mpy6 Int)) (! (or (not (= (select1 ?Spy17 ?x_1py37) true_1)) (not (= (Equal (Intersection (Inverse ?Mpy6 (select1 ?Mpy6 ?x_1py37)) ?Spy17) (Singleton ?x_1py37)) true_1)) (= (Equal (Dereference ?Spy17 (store1 ?Mpy6 ?x_1py37 ?ypy17)) (Union (Difference (Dereference ?Spy17 ?Mpy6) (Singleton (select1 ?Mpy6 ?x_1py37))) (Singleton ?ypy17))) true_1)) :pattern ((Dereference ?Spy17 (store1 ?Mpy6 ?x_1py37 ?ypy17))) )) :named A1_87))
(assert (! (forall ((?x_1py38 Int)(?ypy18 Int)) (! (and (or (not (= (select1 (Singleton ?ypy18) ?x_1py38) true_1)) (= ?x_1py38 ?ypy18)) (or (not (= ?x_1py38 ?ypy18)) (= (select1 (Singleton ?ypy18) ?x_1py38) true_1))) :pattern ((select1 (Singleton ?ypy18) ?x_1py38)) )) :named A1_88))
(assert (! (forall ((?x_1py39 Int)) (! (not (= (select1 Empty ?x_1py39) true_1)) :pattern ((select1 Empty ?x_1py39)) )) :named A1_89))
(assert (! (forall ((?ypy19 Int)) (! (= (select1 (Singleton ?ypy19) ?ypy19) true_1) :pattern ((Singleton ?ypy19)) )) :named A1_90))
(assert (! (not (= array 0)) :named A1_91))
(assert (! (= (HasType analysis_havoc_assert_arg_1_4_ INT4_name) true_1) :named A2_0))
(assert (! (= (HasType array PPINT4_name) true_1) :named A2_1))
(assert (! (= (HasType call4064formal_new_0 PINT4_name) true_1) :named A2_2))
(assert (! (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1) :named A2_3))
(assert (! (= (HasType result_main_13_5_1_ INT4_name) true_1) :named A2_4))
(assert (! (= (HasType result_malloc_14_23_2_ INT4_name) true_1) :named A2_5))
(assert (! (= (HasType x_1 PINT4_name) true_1) :named A2_6))
(assert (! (= (Match call4064formal_new_0 INT4_name) true_1) :named A2_7))
(assert (! (= (Subset Empty (HavocArray call4064formal_new_0 4 10)) true_1) :named A2_8))
(assert (! (= (select1 alloc call4064formal_new_0) UNALLOCATED) :named A2_9))
(assert (! (= (select1 alloc_0 call4064formal_new_0) ALLOCATED) :named A2_10))
(assert (! (forall ((?apy22 Int)) (! (= (HasType (select1 (select1 Mem (Field ?apy22)) ?apy22) (Field ?apy22)) true_1) :pattern ((select1 (select1 Mem (Field ?apy22)) ?apy22)) )) :named A2_11))
(assert (! (forall ((?x_1py40 Int)) (! (or (= (Base ?x_1py40) call4064formal_new_0) (not (<= call4064formal_new_0 ?x_1py40)) (<= call4064formal_new_0 (+ (- 40) ?x_1py40))) :pattern ((Base ?x_1py40)) )) :named A2_12))
(assert (! (forall ((?x_1py41 Int)) (! (or (= ?x_1py41 call4064formal_new_0) (= (select1 alloc ?x_1py41) (select1 alloc_0 ?x_1py41))) :pattern ((select1 alloc_0 ?x_1py41)) )) :named A2_13))
(assert (! (forall ((?x_2py0 Int)) (! (or (not (= (select1 (HavocArray call4064formal_new_0 4 10) ?x_2py0) true_1)) (= (Match ?x_2py0 INT4_name) true_1)) :pattern ((select1 (HavocArray call4064formal_new_0 4 10) ?x_2py0)) )) :named A2_14))
(assert (! (or (not (= (HasType (select1 (select1 Mem (Field ?a!4)) ?a!4) (Field ?a!4)) true_1)) (and (forall ((?apy25 Int)) (! (= (HasType (select1 (select1 Mem (Field ?apy25)) ?apy25) (Field ?apy25)) true_1) :pattern ((select1 (select1 Mem (Field ?apy25)) ?apy25)) )) (or (not (= (HasType analysis_havoc_assert_arg_1_4_ INT4_name) true_1)) (and (= (HasType analysis_havoc_assert_arg_1_4_ INT4_name) true_1) (or (not (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1)) (and (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 INT4_name) true_1)) (and (= (HasType call4064formal_new_0 INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 PINT4_name) true_1)) (and (= (HasType call4064formal_new_0 PINT4_name) true_1) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (= Mem_0 (store1 Mem (Field array) (store1 (select1 Mem (Field array)) array call4064formal_new_0))) (or (not (= (HasType (select1 (select1 Mem_0 (Field ?a!5)) ?a!5) (Field ?a!5)) true_1)) (and (forall ((?apy23 Int)) (! (= (HasType (select1 (select1 Mem_0 (Field ?apy23)) ?apy23) (Field ?apy23)) true_1) :pattern ((select1 (select1 Mem_0 (Field ?apy23)) ?apy23)) )) (or (not (= (HasType analysis_havoc_assert_arg_1_4_ INT4_name) true_1)) (and (= (HasType analysis_havoc_assert_arg_1_4_ INT4_name) true_1) (or (not (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1)) (and (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 INT4_name) true_1)) (and (= (HasType call4064formal_new_0 INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 PINT4_name) true_1)) (and (= (HasType call4064formal_new_0 PINT4_name) true_1) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (= analysis_havoc_assert_arg_1_4__0 (LIFT (anyEqual (select1 (select1 Mem_0 (Field array)) array) call4064formal_new_0))) (or (not (= (HasType (select1 (select1 Mem_0 (Field ?a!5)) ?a!5) (Field ?a!5)) true_1)) (and (forall ((?apy23 Int)) (! (= (HasType (select1 (select1 Mem_0 (Field ?apy23)) ?apy23) (Field ?apy23)) true_1) :pattern ((select1 (select1 Mem_0 (Field ?apy23)) ?apy23)) )) (or (not (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1)) (and (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1) (or (not (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1)) (and (= (HasType result___analysis_havoc_assert_17_25_3_ INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 INT4_name) true_1)) (and (= (HasType call4064formal_new_0 INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 PINT4_name) true_1)) (and (= (HasType call4064formal_new_0 PINT4_name) true_1) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (or (not (= (HasType (select1 (select1 Mem_0 (Field ?a!5)) ?a!5) (Field ?a!5)) true_1)) (and (forall ((?apy23 Int)) (! (= (HasType (select1 (select1 Mem_0 (Field ?apy23)) ?apy23) (Field ?apy23)) true_1) :pattern ((select1 (select1 Mem_0 (Field ?apy23)) ?apy23)) )) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (or (not (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1)) (and (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1) (forall ((?apy23 Int)) (! (= (HasType (select1 (select1 Mem_0 (Field ?apy23)) ?apy23) (Field ?apy23)) true_1) :pattern ((select1 (select1 Mem_0 (Field ?apy23)) ?apy23)) )) (= (HasType array PPINT4_name) true_1) (= (HasType call4300formal_ret_0 INT4_name) true_1) (or (not (= (select1 alloc_0 (Base (select1 (select1 Mem_0 (Field array)) array))) ALLOCATED)) (and (= (select1 alloc_0 (Base (select1 (select1 Mem_0 (Field array)) array))) ALLOCATED) (or (not (= (Base (select1 (select1 Mem_0 (Field array)) array)) (select1 (select1 Mem_0 (Field array)) array))) (and (= (Base (select1 (select1 Mem_0 (Field array)) array)) (select1 (select1 Mem_0 (Field array)) array)) (or (not (= (HasType (select1 (select1 Mem_0 (Field ?a!5)) ?a!5) (Field ?a!5)) true_1)) (and (forall ((?apy23 Int)) (! (= (HasType (select1 (select1 Mem_0 (Field ?apy23)) ?apy23) (Field ?apy23)) true_1) :pattern ((select1 (select1 Mem_0 (Field ?apy23)) ?apy23)) )) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (forall ((?fpy6 Int)) (! (or (= (select1 alloc_0 (Base ?fpy6)) (select1 alloc_1 (Base ?fpy6))) (= (select1 alloc_0 (Base ?fpy6)) UNALLOCATED) (and (= (Base (select1 (select1 Mem_0 (Field array)) array)) (Base ?fpy6)) (not (= (select1 alloc_1 (Base ?fpy6)) UNALLOCATED)))) :pattern ((select1 alloc_1 (Base ?fpy6))) )) (forall ((?fpy7 Int)(?mpy0 Int)) (! (= (select1 (select1 Mem_1 ?fpy7) ?mpy0) (select1 (select1 Mem_0 ?fpy7) ?mpy0)) :pattern ((select1 (select1 Mem_1 ?fpy7) ?mpy0)) )) (= (select1 (select1 Mem_1 (Field 0)) 0) (select1 (select1 Mem_0 (Field 0)) 0)) (forall ((?apy26 Int)) (! (= (HasType (select1 (select1 Mem_1 (Field ?apy26)) ?apy26) (Field ?apy26)) true_1) :pattern ((select1 (select1 Mem_1 (Field ?apy26)) ?apy26)) )) (or (= call4064formal_new_0 0) (and (not (= call4064formal_new_0 0)) (or (not (= (select1 alloc_1 (Base (PLUS call4064formal_new_0 4 5))) ALLOCATED)) (and (= (select1 alloc_1 (Base (PLUS call4064formal_new_0 4 5))) ALLOCATED) (= Mem_2 (store1 Mem_1 (Field (PLUS call4064formal_new_0 4 5)) (store1 (select1 Mem_1 (Field (PLUS call4064formal_new_0 4 5))) (PLUS call4064formal_new_0 4 5) 5))) (or (not (= (HasType (select1 (select1 Mem_2 (Field ?a!6)) ?a!6) (Field ?a!6)) true_1)) (and (forall ((?apy24 Int)) (! (= (HasType (select1 (select1 Mem_2 (Field ?apy24)) ?apy24) (Field ?apy24)) true_1) :pattern ((select1 (select1 Mem_2 (Field ?apy24)) ?apy24)) )) (or (not (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1)) (and (= (HasType analysis_havoc_assert_arg_1_4__0 INT4_name) true_1) (or (not (= (HasType call4300formal_ret_0 INT4_name) true_1)) (and (= (HasType call4300formal_ret_0 INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 INT4_name) true_1)) (and (= (HasType call4064formal_new_0 INT4_name) true_1) (or (not (= (HasType call4064formal_new_0 PINT4_name) true_1)) (and (= (HasType call4064formal_new_0 PINT4_name) true_1) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (forall ((?mpy1 Int)) (! (or (= (select1 alloc (Base ?mpy1)) ALLOCATED) (= (select1 (select1 Mem_2 (Field ?mpy1)) ?mpy1) (select1 (select1 Mem (Field ?mpy1)) ?mpy1)) (= (select1 alloc_1 (Base ?mpy1)) ALLOCATED)) :pattern ((select1 (select1 Mem_2 (Field ?mpy1)) ?mpy1)) )) (or (not (= (HasType array PPINT4_name) true_1)) (and (= (HasType array PPINT4_name) true_1) (or (not (= (HasType result_main_13_5_1_ INT4_name) true_1)) (and (= (HasType result_main_13_5_1_ INT4_name) true_1) (or (not (= (HasType (select1 (select1 Mem_2 (Field ?a!6)) ?a!6) (Field ?a!6)) true_1)) (and (forall ((?apy24 Int)) (! (= (HasType (select1 (select1 Mem_2 (Field ?apy24)) ?apy24) (Field ?apy24)) true_1) :pattern ((select1 (select1 Mem_2 (Field ?apy24)) ?apy24)) )) (or (and (or (not (= ?m!7 array)) (not (= ?f!8 (Field array)))) (not (= (select1 (select1 Mem_2 ?f!8) ?m!7) (select1 (select1 Mem ?f!8) ?m!7)))) (and (forall ((?fpy8 Int)(?mpy2 Int)) (! (or (= (select1 (select1 Mem_2 ?fpy8) ?mpy2) (select1 (select1 Mem ?fpy8) ?mpy2)) (and (= ?mpy2 array) (= ?fpy8 (Field array)))) :pattern ((select1 (select1 Mem_2 ?fpy8) ?mpy2)) )) (not (= (select1 alloc (Base ?f!9)) UNALLOCATED)) (not (= (select1 alloc (Base ?f!9)) (select1 alloc_1 (Base ?f!9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) :named A2_15))
(assert (! (not (<= call4064formal_new_0 0)) :named A2_16))
(check-sat)
(get-info :reason-unknown)
;z3 -T:600 group_006/ematching/tmp/havoc-bench_024.2.main_std_unique_aug-gt_unsat-full.smt2
;unknown
;((:reason-unknown "smt tactic failed to show goal to be sat/unsat (incomplete quantifiers)"))
